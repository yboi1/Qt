## 1.explicity的作用

防止编译器自动优化



## 2.在堆区申请一个空间和在堆区释放一个空间

```
class Maker
{
public:
	Maker()
	{
		cout << "构造函数" << endl;
	}
	~Maker()
	{
		cout << "析构函数" << endl;
	}
};
void test01()
{
	Maker* m = new Maker;
	delete m;
}
int main()
{
	test01();
	return 0;
}
```

new：申请一个空间   delete ：释放空间

1.如果new申请的时候有中括号，释放时也要有中括号

2.   delete void* 可能会报错，因为编译器可能没发找到指向哪个函数，无法

调用析构函数

## 3.静态成员变量

1.静态成员在类内声明，在类外初始化

2.静态成员变量的生命周期是整个程序，作用域在类内

3.静态成员变量属于类，不属于对象，是所有对象所共有的

4.静态成员可以用类访问，也可以用对象访问

```
class Maker
{
public:
	static int m;
};
int	Maker::m = 10;  //用类的方式访问
void test02()
{
    
	Maker s;
	cout << s.m << endl;
}
int main()
{
	test02();
	return 0;
}
```

5.静态函数只能访问静态成员，不能访问一般函数成员

6.静态成员也有私有权限，类外也不能访问

7.const修饰的静态成员变量最好在类内初始化

8.普通成员函数可以访问静态成员变量





## 4.C++的对象模型

1.空类的大小为1，不是0  （为了更好的为类分配空间）

2.类的成员函数不占用类的大小，静态成员变量不占用类的大小

   静态成员函数不占用类的大小

3.普通成员变量占用类的大小！

4.类的成员中，成员函数和成员变量是分开储存的

当创建一个普通成员函数时，编译器自动传入了一个this指针，指向成员变量

## 5.this指针

1.每个对象都有一个隐式的this指针，但是不属于对象，是编译器自动添加的

2.编译器会把this指针传入成员函数，this指针指向成员的储存空间

3.this指针不会改变sizeof（对象）的大小

4.this指针的作用：  

（1） 当形参名与成员变量名相同时，用this指针区分

（2）返回形参对象本身时

**扩展**：

1.this指针指向的空间没有储存静态成员变量

2.this指针的指向对象不能改变，因为一旦改变，编译器便无法找到对象

也就是说this是Maker*const this；（顶层指针）

## 6.常函数和常对象

作用：如果不想修改成员变量时，将其定义为常函数或常变量

### 常函数：

1.在函数（）后面加上const，表明函数为常函数

2.常函数中不能修改普通成员变量

3.常函数的this指针为const指针：const Maker*const  m；

4.由mutable 修饰的变量可以在常函数中修改

### 常对象：

1.const  Maker  m(1,23)；

2.常对象不能修改普通变量的值

3.常对象不能调用普通成员函数

4.常对象可以调用常函数

5.常对象可以修改mutable修饰的成员变量

#### 总结：

常函数和常对象不能修改成员变量，但是可以修改**mutable**修饰的变量

**常对象只能调用常函数**，普通成员变量也可以调用常函数

## 7.友元

友元是赋予全局函数，类的成员函数，类有访问私有成员的权限

注：友元函数不是类的成员函数