# 类的继承规则

## 1.继承的概念

```
class Son: public Father
{

};
```

1.子类拥有父类的功能

2.子类可以开辟新功能

## 2.继承的方式

> 1.公有继承
>
> ​	1.父类的公有属性成员，到子类还是公有
> ​	2.父类的私有属性成员，到子类不能访问
> ​	3.父类的保护属性成员，到子类还是保护	
>
> 2.保护继承
>
> ​	1.父类的公有属性成员，到子类是保护
> ​	2.父类的私有属性成员，到子类不能访问
> ​	3.父类的保护属性成员，到子类还是保护	
>
> 3.私有继承
>
> ​	1.父类的公有属性成员，到子类还是私有
> ​	2.父类的私有属性成员，到子类不能访问
> ​	3.父类的保护属性成员，到子类还是私有	

所有继承中 父类的私有权限都不能访问

公有继承中子类会继承父类的权限

保护继承除私有不能访问外都变成了保护权限

私有继承除私有不能访问外，都变成了私有权限

## 3.继承中的构造和析构

1.父类的构造

先调用父类的构造函数，在调用子类的构造函数，先调用子类的析构函数，再调用父类的析构函数

2.组合的父类和成员

先调用父类的成员的构造函数，再调用父类的构造函数，在调用子类成员的构造函数，再调用子类的构造函数，析构函数的机制类似于栈，后构造的先析构

也即：构造的调用顺序

1.父类成员的构造

2.父类的构造

3.子类成员的构造

4.子类的构造

## 4.继承中同名成员的处理方法

1.当子类中有与父类同名的成员时，子类中的成员会自动隐藏父类的同名成员（注：是隐藏不是替代，父类的同名成员任然会占用内存） 

2.当子类中有与父类同名的函数时，会屏蔽父类中所有的函数重载

**解决方法：**可以通过添加作用域的方式来访问父类的成员及成员函数

```
class Father
{
public:	
	int a;
};
class Son:public Father
{
public:	
	int a;
};
void test()
{
	Son m;
	m.a;//此时访问的是子类的成员a
	m.Father:a;//此时访问的是父类的成员a
}
```

## 5.继承中静态成员特性

> 1.静态成员可以被继承
>
> 2.继承中的静态成员变量一样会被同名的子类成员变量隐藏
>
> 3.继承中的静态成员函数中，当子类有和父类同名静态函数时，父类的所有重载静态函数都会被隐藏
>
> **4.改变从基类继承过来的静态函数的某个特征，返回值或者参数个数，将会隐藏基类重载的函数**
>
> **5.静态成员函数不能是虚函数**？
>
> **6.从父类继承过来的静态成员变量是父类的静态成员变量**

## 6.多继承

1.多继承是指一个类继承了多个父类

2.多继承的问题时，当继承的多个父类中有同名成员时，会出现二义性

**但是可以通过添加作用域的方式来避免二义性**

```
class Father1
{
public:
	Father1()
	{
		a = 10;
	}
public:
	int a;
};
class Father2
{
public:
	Father2()
	{
		a = 20;
	}
public:
	int a;
};
class Son :public Father1, public Father2
{

};
void test()
{
	Son s1;
	cout << s1.Father2::a << endl;
	
}
int main()
{
	test();
}
```

## 7.菱形继承

概念：一个父类，被两个子类所继承，然后两个子类被一个类所继承，造成了一个父类被拷贝了两次，产生了二义性

解决：

#### 1.虚基类

被虚继承的基类叫做虚基类

#### 2.虚继承

父类虚继承祖类，用关键字virtual关键字

#### 3.虚继承的原理

​	1.编译器给类添加了一个指针，指针指向了类似于表的组织，该表记录了该指针距离变量的偏移量

​	2.当子类多继承两个父类，那么只有一份成员变量，然后有两个指针，只有一个成员变量，所以没有二义性

 



#### 4.读取祖类的数据（难点！）

```
Sheep s;
	/*
		1.得到地址  &s
		2.强转为指针类型 (int *)&s
		3.得到指针所指的地址 *(int *)&s
		4.将地址强转为指针 (int *)(*(int *)&s)
		5.将指针加一得到偏移量 (int *)(*(int *)&s)+1
		6.解引用得到偏移量  *((int *)(*(int *)&s)+1)
	*/
	cout << *((int*)(*(int*)&s) + 1) << endl;
	
	/*
		1.得到地址 &s
		2.强转为指针(char*)&s
		3.(char*)&s+(*((int *)(*(int *)&s)+1))
	*/
	cout << ((Animal*)((char*)&s + (*((int*)(*(int*)&s) + 1))))->mA << endl;
```

